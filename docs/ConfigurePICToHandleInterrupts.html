<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Bare Metal Rust 3: Configure your PIC to handle interrupts correctly | Random Hacks</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="Random code snippets, projects and musings about software from Eric Kidd, a developer and entrepreneur.">
    <link rel="icon" href="http://www.randomhacks.net/favicon.ico">
    <link rel="canonical" href="http://www.randomhacks.net/2015/11/16/bare-metal-rust-configure-your-pic-interrupts/">
    
      <link rel="alternate" type="application/rss+xml" title="Random Hacks blog posts" href="http://www.randomhacks.net/feed.xml">
    

<script async="" src="ConfigurePICToHandleInterrupts_files/analytics.js"></script><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-24549236-2', 'randomhacks.net');
  ga('send', 'pageview');

</script>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="ConfigurePICToHandleInterrupts_files/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="http://www.randomhacks.net/">Random Hacks</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
        </svg>
      </a>
    </nav>

  </div>

</header>

<div class="wrap">
  <div class="site-intro">Random code snippets, projects and musings about software from Eric Kidd, a developer and entrepreneur. You're welcome to <a href="http://www.randomhacks.net/contact/">contact me</a>!</div>
</div>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>Bare Metal Rust 3: Configure your PIC to handle interrupts correctly</h1>
    <p class="meta">Nov 16, 2015 • by Eric Kidd</p>
  </header>

  <article class="post-content">
  <p><em>Want to build your own kernel in Rust?  See <a href="http://www.randomhacks.net/bare-metal-rust/">Bare Metal Rust</a> to get
started.</em></p>

<p>We're almost ready to write a keyboard driver in Rust!  But first, we need
to deal with two obstacles: setting up the PIC, and handling interrupts
without crashing.  This is one of the most frustrating steps, as Julia
Evans explains in her hilarious and very helpful post
<a href="http://jvns.ca/blog/2013/12/04/day-37-how-a-keyboard-works/">After 5 days, my OS doesn't crash when I press a key</a>:</p>

<blockquote>
<ol start="9">
<li>Turn interrupts on (<code>sti</code>).</li>
<li>The OS AGAIN crashes every time i press a key. Read “I Can’t Get
Interrupts Working” again. This is called “I’m receiving EXC9 instead
of IRQ1 when striking a key?!” Feel on top of this.</li>
<li>Remap the PIC so that interrupt <code>i</code> gets mapped to <code>i + 32</code>,
because of an Intel design bug. This <i>basically</i> looks like just
typing in a bunch of random numbers, but it works.</li>
<li>12. THE OS IS STILL CRASHING WHEN I PRESS A KEY. This continues for 2
days.</li>
</ol>
</blockquote>

<p>We're going to follow Julia Evans' roadmap. (She saved me several days of
suffering.)  And once we're past these next few obstacles, things will get
easier.  Let's talk to the PIC first.</p>

<h2>The 8295/8295A Programmable Interrupt Controller</h2>

<p>We're going to with the retro approach here, and handle interrupts using
the 8295 PIC.  You can <a href="http://wiki.osdev.org/8259_PIC">read all about it</a> on the OSDev wiki, as
usual.  The PIC works fine in 64-bit mode, but someday, if we want to
support multiple processors and I/O, we'll eventually need to support the
newer <a href="http://wiki.osdev.org/APIC">APIC</a> and <a href="http://wiki.osdev.org/IOAPIC">IOAPIC</a>.  But for now, let's keep it simple.</p>

<p>Technically, the x86 architecture has two PIC chips, usually known as PIC1
and PIC2.  PIC1 handles external interrupts 0–7, and PIC2 handles 8–15.
PIC2 is actually chained into interrupt 2 on PIC1, which means that we'll
frequently need to talk to them as a pair.</p>

<p>Unfortunately, the modern x86 architecture reserves CPU interrupts 0-31 for
processor exceptions.  This means that when we press a key, the CPU will
think it just received the "EXC9" mentioned by Julia Evans, which the Intel
manual tells me is "Coprocessor-Segment-Overrun Exception."  So we need to
tell our PIC that, no, <em>McGyver</em> and <em>Miami Vice</em> are no longer
cutting-edge television, that there's this new-fangled thing called 386
Protected Mode, and that it needs to start mapping interrupts at offset 32.</p>

<!--more-->

<h2>Making <code>Port</code> more paranoid</h2>

<p><a href="http://www.randomhacks.net/2015/11/09/bare-metal-rust-cpu-port-io/">In an earlier post</a>, we talked about "ports", and we defined a
<code>cpuio::Port</code> that we could use to talk to common hardware peripherals.
This had an odd interface, where <code>new</code> was marked as <code>unsafe</code> (because
some ports are dangerous), but where <code>read</code> and <code>write</code> were marked as
safe.  The theory is that whoever called <code>new</code> could control who had access
to <code>read</code> and <code>write</code>.</p>

<p>But <a href="https://www.reddit.com/r/rust/comments/3s4lj4/bare_metal_rust_lowlevel_cpu_io_ports/cwusyx9">dschatzberg on /r/rust pointed out</a> that this wasn't
always a helpful way to represent the hardware, because it placed too big a
burden on the code that called <code>new</code>.  So let's create a second 
<code>UnsafePort</code>, which works just like <code>Port</code> except <em>all</em> the methods are
marked as <code>unsafe</code>.  Here's the new code from the <a href="https://github.com/emk/toyos.rs/tree/master/crates/cpuio">cpuio</a> crate:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">UnsafePort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">InOut</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">port</span><span class="o">:</span> <span class="k">u16</span><span class="p">,</span>
    <span class="n">phantom</span><span class="o">:</span> <span class="n">PhantomData</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">InOut</span><span class="o">&gt;</span> <span class="n">UnsafePort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">new</span><span class="p">(</span><span class="n">port</span><span class="o">:</span> <span class="k">u16</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnsafePort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">UnsafePort</span> <span class="p">{</span> <span class="n">port</span><span class="o">:</span> <span class="n">port</span><span class="p">,</span> <span class="n">phantom</span><span class="o">:</span> <span class="n">PhantomData</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">read</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span> <span class="p">{</span>
        <span class="n">T</span><span class="o">::</span><span class="n">port_in</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">,</span> <span class="n">value</span><span class="o">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span><span class="o">::</span><span class="n">port_out</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>We can use this to access any hardware which is intrinsically "unsafe," in
the Rust sense of the term, where merely calling <code>read</code> and <code>write</code> might
<a href="https://doc.rust-lang.org/stable/nomicon/meet-safe-and-unsafe.html">cause undefined behavior and violate Rust's safety guarantees</a>.
This is appropriate for working with the PIC, because a misconfigured PIC
can cause interrupts to corrupt memory.</p>

<h2>Talking to a single PIC</h2>

<p>I learned everything that follows from the OSDev wiki's <a href="http://wiki.osdev.org/8259_PIC">PIC page</a>.
So please don't assume I'm any kind of expert on this stuff—I'm going to
make mistakes, and I spent a bunch of time watching QEMU reboot.  Your
corrections and improvements would definitely be appreciated!</p>

<p>Each PIC has two 8-bit ports: one for sending commands, and one for sending
and receiving data.  Additionally, each PIC has an <code>offset</code>, which we'll
use to control the mapping from PIC interrupts to CPU interrupts.  We can
represent this as:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="n">crate</span> <span class="n">cpuio</span><span class="p">;</span>

<span class="k">use</span> <span class="n">cpuio</span><span class="o">::</span><span class="n">UnsafePort</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Pic</span> <span class="p">{</span>
    <span class="n">offset</span><span class="o">:</span> <span class="k">u8</span><span class="p">,</span>
    <span class="n">command</span><span class="o">:</span> <span class="n">UnsafePort</span><span class="o">&lt;</span><span class="k">u8</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">data</span><span class="o">:</span> <span class="n">UnsafePort</span><span class="o">&lt;</span><span class="k">u8</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>Each PIC handles a total of 8 interrupts, starting at the CPU interrupt
<code>offset</code> and counting from there.  So let's define some helper methods:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Pic</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">handles_interrupt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">interupt_id</span><span class="o">:</span> <span class="k">u8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">interupt_id</span> <span class="o">&amp;&amp;</span> <span class="n">interupt_id</span> <span class="o">&lt;</span> <span class="n">self</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="m">8</span>
    <span class="p">}</span>

    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">end_of_interrupt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">command</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">CMD_END_OF_INTERRUPT</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>We'll use the <code>end_of_interrupt</code> command to tell the PIC when we're done
processing an interupt.</p>

<h2>Representing a chained pair of PICs</h2>

<p>But our PIC1 and PIC2 chips are chained together, and they work as a pair.
So let's create a data structure to represent them:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">struct</span> <span class="n">ChainedPics</span> <span class="p">{</span>
    <span class="n">pics</span><span class="o">:</span> <span class="p">[</span><span class="n">Pic</span><span class="p">;</span> <span class="m">2</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div>
<p>Let's make it easy to set up PIC1 and PIC2, using the standard port
addresses for each, and custom interrupt offsets:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">ChainedPics</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">const</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">new</span><span class="p">(</span><span class="n">offset1</span><span class="o">:</span> <span class="k">u8</span><span class="p">,</span> <span class="n">offset2</span><span class="o">:</span> <span class="k">u8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ChainedPics</span> <span class="p">{</span>
        <span class="n">ChainedPics</span> <span class="p">{</span>
            <span class="n">pics</span><span class="o">:</span> <span class="p">[</span>
                <span class="n">Pic</span> <span class="p">{</span>
                    <span class="n">offset</span><span class="o">:</span> <span class="n">offset1</span><span class="p">,</span>
                    <span class="n">command</span><span class="o">:</span> <span class="n">UnsafePort</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0x20</span><span class="p">),</span>
                    <span class="n">data</span><span class="o">:</span> <span class="n">UnsafePort</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0x21</span><span class="p">),</span>
                <span class="p">},</span>
                <span class="n">Pic</span> <span class="p">{</span>
                    <span class="n">offset</span><span class="o">:</span> <span class="n">offset2</span><span class="p">,</span>
                    <span class="n">command</span><span class="o">:</span> <span class="n">UnsafePort</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0xA0</span><span class="p">),</span>
                    <span class="n">data</span><span class="o">:</span> <span class="n">UnsafePort</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0xA1</span><span class="p">),</span>
                <span class="p">},</span>
            <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Now we're ready to actually configure our PIC.</p>

<h2>How would we do this in C?  The OSDev wiki knows!</h2>

<p>We can find an <a href="http://wiki.osdev.org/8259_PIC">example <code>PIC_remap</code> function</a> on the OSDev wiki.
Looking at their code, we can see it has the following structure:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Save interrupt masks.</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">);</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">);</span>

<span class="c1">// Send command: Begin 3-byte initialization sequence.</span>
<span class="c1">// Send data 1: Set interrupt offset.</span>
<span class="c1">// Send data 2: Configure chaining.</span>
<span class="c1">// Send data 3: Set mode.</span>

<span class="c1">// Restore interrupt masks.</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="n">a1</span><span class="p">);</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="n">a2</span><span class="p">);</span>
</code></pre></div>
<p>The initialization of the two PIC chips is interleaved, apparently because
it takes the chips a while to process the messages.  If we send messages
too quickly, the PICs get confused.</p>

<p>First, we begin the initialization.  We need to write a byte to each port,
and call a function <code>io_wait</code> to slow us down even further (more on that
later):</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Send command: Begin 3-byte initialization sequence.</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_COMMAND</span><span class="p">,</span> <span class="n">ICW1_INIT</span><span class="o">+</span><span class="n">ICW1_ICW4</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_COMMAND</span><span class="p">,</span> <span class="n">ICW1_INIT</span><span class="o">+</span><span class="n">ICW1_ICW4</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
</code></pre></div>
<p>Now our PICs each expect us to send a 3-byte initialization sequence.  The
first byte is the offset:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Send data 1: Set interrupt offset.</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="n">offset1</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="n">offset2</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
</code></pre></div>
<p>We follow this with some instructions on how the two PICs are chained
together:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Send data 2: Configure chaining.</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
</code></pre></div>
<p>And finally we specify what mode we want the PICs to run in:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Send data 3: Set mode.</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC1_DATA</span><span class="p">,</span> <span class="n">ICW4_8086</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
<span class="n">outb</span><span class="p">(</span><span class="n">PIC2_DATA</span><span class="p">,</span> <span class="n">ICW4_8086</span><span class="p">);</span>
<span class="n">io_wait</span><span class="p">();</span>
</code></pre></div>
<h2>Translating initialization to Rust</h2>

<p>Now, in Rust, <a href="http://www.randomhacks.net/2015/11/09/bare-metal-rust-cpu-port-io/">we could just use <code>outb</code> directly</a>, and declare values
like <code>PIC1_DATA</code> and <code>ICW4_8086</code> as constants.  This would allow us to
translate the C code literally, and it would be perfectly fine for a chip
as simple as the PIC.</p>

<p>But later on, we'll be dealing with more complicated hardware, which has
lots of I/O ports, and complicated messages.  So let's try to write our
Rust at a higher level of abstraction.  This is overkill now, but it might
make our more complicated drivers easier to understand later on.</p>

<p>First, a skeleton:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">ChainedPics</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">wait_port</span><span class="o">:</span> <span class="n">cpuio</span><span class="o">::</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">cpuio</span><span class="o">::</span><span class="n">Port</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">wait</span> <span class="o">=</span> <span class="o">||</span> <span class="p">{</span> <span class="n">wait_port</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">};</span>

        <span class="k">let</span> <span class="n">saved_mask1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">saved_mask2</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

        <span class="c1">// Send initialization command and data bytes.</span>
        <span class="c1">// ...</span>

        <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">saved_mask1</span><span class="p">);</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">saved_mask2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>But what's up with <code>wait_port</code> and <code>wait</code>?  Well, do you remember <code>io_wait</code>
in the C code above?  We need to wait for a while to slow down our
initialization sequence.  Normally, we'd definite a function like <code>udelay</code>
and call <code>udelay(2)</code> to pause for approximately two microseconds.  But this
won't work, because don't have a clock yet!  Most of the available clocks
require us to have set up our interrupts, and setting up interrupts
requires correctly configured PICs.</p>

<p>There's a traditional way to break this deadlock, which is
<a href="https://github.com/mjg59/kexec-tools/blob/master/kexec_test/x86-setup-legacy-pic.S">demonstrated by kexec's PIC driver</a> and
<a href="http://wiki.osdev.org/Inline_Assembly/Examples#IO_WAIT">explained by the OSDev wiki</a>:</p>
<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="nf">movb</span> <span class="no">$0x11</span><span class="p">,</span> <span class="nv">%al</span>
<span class="nf">outb</span> <span class="nv">%al</span><span class="p">,</span> <span class="no">$0x20</span>
<span class="nf">outb</span> <span class="nv">%al</span><span class="p">,</span> <span class="no">$0x80</span>
</code></pre></div>
<p>Recognize those first two lines?  We just saw them above in C, where they
appeared as <code>outb(PIC1_COMMAND, ICW1_INIT+ICW1_ICW4)</code>.  The third line
writes the same data to port 0x80, which is apparently harmless, but which
takes just long enough for the PICs to be ready again.  If it's good enough
for kexec, we can probably assume it works on most real hardware.</p>

<p>In Rust, we can declare a <code>Port</code> for 0x80 as follows:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">wait_port</span><span class="o">:</span> <span class="n">cpuio</span><span class="o">::</span><span class="n">Port</span><span class="o">&lt;</span><span class="k">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">cpuio</span><span class="o">::</span><span class="n">Port</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
</code></pre></div>
<p>...and declare a local <code>wait</code> function as a closure (a function which can
access local variables) like this:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">let</span> <span class="k">mut</span> <span class="n">wait</span> <span class="o">=</span> <span class="o">||</span> <span class="p">{</span> <span class="n">wait_port</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">};</span>
</code></pre></div>
<p>Now we can translate the initialization sequence into Rust as follows:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="c1">// Send command: Begin 3-byte initialization sequence.</span>
<span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">command</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">CMD_INIT</span><span class="p">);</span>
<span class="n">wait</span><span class="p">();</span>
<span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">command</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">CMD_INIT</span><span class="p">);</span>
<span class="n">wait</span><span class="p">();</span>

<span class="c1">// Send data 1: Set interrupt offset.</span>
<span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
<span class="n">wait</span><span class="p">();</span>
<span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">offset</span><span class="p">);</span>
<span class="n">wait</span><span class="p">();</span>
</code></pre></div>
<p>The remaining two data bytes are left as an exercise for the reader.</p>

<h2>The last two pieces of our API</h2>

<p>First, we need some way to identity which interrupts are managed by our
<code>ChainedPics</code>.  This is easy:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">ChainedPics</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="n">handles_interrupt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span> <span class="n">interrupt_id</span><span class="o">:</span> <span class="k">u8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">bool</span> <span class="p">{</span>
        <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">any</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span> <span class="n">p</span><span class="p">.</span><span class="n">handles_interrupt</span><span class="p">(</span><span class="n">interrupt_id</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>And finally, we need a way to tell the PIC that we've handled an interrupt.
This is slighly tricky, because the interrupts from PIC2 are chained
through PIC1:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">ChainedPics</span> <span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">notify_end_of_interrupt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">self</span><span class="p">,</span> <span class="n">interrupt_id</span><span class="o">:</span> <span class="k">u8</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">handles_interrupt</span><span class="p">(</span><span class="n">interrupt_id</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">handles_interrupt</span><span class="p">(</span><span class="n">interrupt_id</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">end_of_interrupt</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="n">self</span><span class="p">.</span><span class="n">pics</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">end_of_interrupt</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2>Using our PICs</h2>

<p>In our kernel, we can declare our PICs as follows, using
<a href="https://github.com/mvdnes/spinlock-rs"><code>spin::Mutex</code></a> as <a href="http://os.phil-opp.com/printing-to-screen.html">recommended by Philipp Oppermann</a>:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">extern</span> <span class="n">crate</span> <span class="n">spin</span><span class="p">;</span>
<span class="k">use</span> <span class="n">spin</span><span class="o">::</span><span class="n">Mutex</span><span class="p">;</span>

<span class="k">static</span> <span class="n">PICS</span><span class="o">:</span> <span class="n">Mutex</span><span class="o">&lt;</span><span class="n">ChainedPics</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="n">Mutex</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="k">unsafe</span> <span class="p">{</span> <span class="n">ChainedPics</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">)</span> <span class="p">});</span>
</code></pre></div>
<p>We can initialize our PICs as follows:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">PICS</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">initialize</span><span class="p">();</span>
</code></pre></div>
<p>...and let them know when we're done processing an interrupt:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="n">PICS</span><span class="p">.</span><span class="n">lock</span><span class="p">().</span><span class="n">notify_end_of_interrupt</span><span class="p">(</span><span class="n">interrupt_id</span><span class="p">);</span>
</code></pre></div>
<h2>Not yet implemented: Masking &amp; spurious interrupts</h2>

<p>The current version of this code offers no way to selectively mask and
unmask interrupts.  We won't need that right away.</p>

<p>We also have no support for handling "spurious interrupts."  The
<a href="http://wiki.osdev.org/8259_PIC#Spurious_IRQs">OSDev wiki explains</a>:</p>

<blockquote>
<p>When an IRQ occurs, the PIC chip tells the CPU (via. the PIC's INTR line)
that there's an interrupt, and the CPU acknowledges this and waits for
the PIC to send the interrupt vector. This creates a race condition: if
the IRQ disappears after the PIC has told the CPU there's an interrupt
but before the PIC has sent the interrupt vector to the CPU, then the CPU
will be waiting for the PIC to tell it which interrupt vector but the PIC
won't have a valid interrupt vector to tell the CPU.</p>

<p>To get around this, the PIC tells the CPU a fake interrupt number. This
is a spurious IRQ. The fake interrupt number is the lowest priority
interrupt number for the corresponding PIC chip (IRQ 7 for the master
PIC, and IRQ 15 for the slave PIC).</p>

<p>There are several reasons for the interrupt to disappear. In my
experience the most common reason is software sending an EOI at the wrong
time. Other reasons include noise on IRQ lines (or the INTR line).</p>
</blockquote>

<p>Linux keeps track of spurious interrupts.  You can see the counters by
running:</p>
<div class="highlight"><pre><code class="language-sh" data-lang="sh">cat /proc/irq/*/spurious <span class="p">|</span> less
</code></pre></div>
<p>Apparently, there are other kinds of spurious interrupts besides the ones
described above.  <a href="https://lwn.net/Articles/392136/">Linux Weekly News has an article</a> talking about how
modern Linux kernels handle this on especially unreliable hardware.  But
I'm going to try to ignore this until after we get the keyboard working.</p>

<h2>Available on GitHub &amp; crates.io</h2>

<p>This code is available
<a href="https://github.com/emk/toyos.rs/tree/master/crates/pic8259_simple">as a Rust crate named <code>pic8259_simple</code></a>, which you can
import into your kernel by add the following your <code>Cargo.toml</code> file:</p>
<div class="highlight"><pre><code class="language-toml" data-lang="toml"><span class="p">[</span><span class="n">dependencies</span><span class="p">]</span>
<span class="n">pic8259_simple</span> <span class="o">=</span> <span class="s">"0.1.0"</span>
<span class="n">spin</span> <span class="o">=</span> <span class="s">"0.3.4"</span>
</code></pre></div>
<p>You can submit bug reports (and pull requests) <a href="https://github.com/emk/toyos.rs/issues">on GitHub</a>.  Your
improvements are welcome!</p>

<h2>Where to next?</h2>

<p>We're getting closer to a working keyboard!  We still need to set up
interrupts, and then write a simple keyboard driver.</p>

<p>But in the meantime, why not check out Philipp Oppermann's post
<a href="http://os.phil-opp.com/allocating-frames.html">Allocating Frames</a>, which explains how to figure out how much RAM
you have available, and allocate it on demand?</p>

<p>If you have any questions—or if you want to suggest improvements to this
code—I'll be keeping on eye on the <a href="https://www.reddit.com/r/rust/comments/3t0e6c/bare_metal_rust_3_configure_your_pic_to_handle/">Reddit discussion</a>.</p>

<p><em>Want to build your own kernel in Rust?  See <a href="http://www.randomhacks.net/bare-metal-rust/">Bare Metal Rust</a> to get
started.</em></p>

  </article>

  
    <div class="related">
      <h3>More posts</h3>
      <ul>
        
          <li><a href="http://www.randomhacks.net/2015/11/09/bare-metal-rust-cpu-port-io/">Bare Metal Rust: Low-level CPU I/O ports</a></li>
        
          <li><a href="http://www.randomhacks.net/2015/11/11/bare-metal-rust-custom-target-kernel-space/">Bare Metal Rust 2: Retarget your compiler so interrupts are not evil</a></li>
        
          <li><a href="http://www.randomhacks.net/2002/11/10/ll2/">Lightweight Languages 2 Conference (MIT, 2002)</a></li>
        
          <li><a href="http://www.randomhacks.net/2007/03/03/smart-classification-with-haskell/">Smart classification using Bayesian monads in Haskell</a></li>
        
          <li><a href="http://www.randomhacks.net/2011/04/25/aws-outage-timeline-and-recovery-strategy-downtimes/">AWS outage timeline &amp; downtimes by recovery strategy</a></li>
        
      </ul>
    </div>
  

  <div class="action">
  <p>Want to <a href="http://www.randomhacks.net/contact/">contact me</a> about this article?  Or if you're looking for something else to read, here's a <a href="http://www.randomhacks.net/greatest-hits/">list of popular posts</a>.</p>
</div>


  
</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">

    <h2 class="footer-heading">Random Hacks</h2>

    <div class="footer-col-1 column">
      <ul>
        <li>Random Hacks</li>
        <li><a href="http://www.randomhacks.net/contact/">Contact me</a></li>
        <li><a href="http://kiddsoftware.com/">Kidd Software LLC</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="http://www.randomhacks.net/portfolio/">
            <img src="ConfigurePICToHandleInterrupts_files/icon.gif" align="middle">
            Portfolio
          </a>
        </li>
        <li>
          <a href="https://github.com/emk">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path>
              </svg>
            </span>
            <span class="username">emk</span>
          </a>
        </li>
        <li>
          <a href="https://twitter.com/ericmkidd">
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path>
              </svg>
            </span>
            <span class="username">ericmkidd</span>
          </a>
        </li>
        <li>
          
            <a href="https://plus.google.com/+EricKidd?rel=author">
              <span class="icon google-plus">
                <img src="ConfigurePICToHandleInterrupts_files/gplus-16.png" alt="Google+" style="border:0;width:16px;height:16px;" align="middle">
              </span>
              <span class="username">+EricKidd</span>
            </a>
          
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">Random code snippets, projects and musings about software from Eric Kidd, a developer and entrepreneur.</p>
    </div>

  </div>

</footer>

<script></script>


    
</body></html>